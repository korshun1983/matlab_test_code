function [MeshNodesCubic,MeshTriCubic,MeshProps] = AddNodesCubic(MeshNodes,MeshTri)
     
%   Part of the toolbox for solving problems of wave propagation
% in arbitrary anisotropic inhomogeneous waveguides.
% For details see User manual 
% and comments to the main script gen_aniso.m
%
%   AddNodesCubic function takes the triangles from the linear triangular
%   mesh generated by the Mesh2d v24 package and transforms them into the
%   cubic triangles by adding 7 more nodes (on edges and one internal) as
%   described in the book by Zienkiewicz
% NB!!! This implementation is specific for FE computations
%
%   [D.Syresin, T.Zharnikov, SMR v0.3_08.2014]
%
% function [MeshNodesCubic,MeshTriCubic,el_var] = AddNodesCubic(MeshNodes,MeshTri)
%
%  Inputs - 
%
%       CompStruct - structure containing parameters of the model
%
%  Outputs -
%
%       Pos - structure array, indicating positions of the blocks corresponding
%               to the various hierarchy levels (layers, harmonics, variables) 
%               inside the full matrix representation matrix.
%
%  M-files required-
%
% Last Modified by Timur Zharnikov SMR v0.3_08.2014

%###############################################################################
%
%   Code for AddNodesCubic
%
%###############################################################################
%===============================================================================
% Initialization
%===============================================================================

% make the triangles array for the cubic triangular mesh
MeshTriCubic = zeros(11, length(MeshTri));
MeshNodesCubic = MeshNodes;
% populate corner nodes from the linear mesh
MeshTriCubic([1:3,11],:) = MeshTri(1:4,:);
% introduce the arrays for the x and y coordinates of the corner nodes of
% the triangles
NodesX = zeros(1,3);
NodesY = zeros(1,3);
% introduce the array for various properties of the cubic triangle
MeshProps.DS = zeros(11,length(MeshTri));
MeshProps.delta = zeros(1,length(MeshTri));
MeshProps.a = zeros(3,length(MeshTri));
MeshProps.b = zeros(3,length(MeshTri));
MeshProps.c = zeros(3,length(MeshTri));

%===============================================================================
% Process all of the triangles of the linear triangular mesh and add 7
% nodes (6 on edge and 1 central) to each triangle to make the mesh cubic
%===============================================================================

for ii=1:length(MeshTri)
    % get the coordinates of the corner nodes
    NodesX(:) = MeshNodes(1,MeshTri(1:3,ii));
    NodesY(:) = MeshNodes(2,MeshTri(1:3,ii));
    
    % populate corner nodes of the cubic triangle
    NodesCubicX([1;2;3]) = NodesX;
    NodesCubicY([1;2;3]) = NodesY;
    
    % compute the coordinates of the edge nodes
    NodesCubicX(4) = ( 2*NodesCubicX(1) + NodesCubicX(2) )/3;
    NodesCubicY(4) = ( 2*NodesCubicY(1) + NodesCubicY(2) )/3;
    
    NodesCubicX(5) = ( NodesCubicX(1) + 2*NodesCubicX(2) )/3;
    NodesCubicY(5) = ( NodesCubicY(1) + 2*NodesCubicY(2) )/3;
    
    NodesCubicX(6) = ( 2*NodesCubicX(2) + NodesCubicX(3) )/3;
    NodesCubicY(6) = ( 2*NodesCubicY(2) + NodesCubicY(3) )/3;
     
    NodesCubicX(7) = ( NodesCubicX(2) + 2*NodesCubicX(3) )/3;
    NodesCubicY(7) = ( NodesCubicY(2) + 2*NodesCubicY(3) )/3;
    
    NodesCubicX(8) = ( NodesCubicX(1) + 2*NodesCubicX(3) )/3;
    NodesCubicY(8) = ( NodesCubicY(1) + 2*NodesCubicY(3) )/3;
    
    NodesCubicX(9) = ( 2*NodesCubicX(1) + NodesCubicX(3) )/3;
    NodesCubicY(9) = ( 2*NodesCubicY(1) + NodesCubicY(3) )/3;
    
    % compute the coordinates of the central node
    NodesCubicX(10) = ( NodesCubicX(1) + NodesCubicX(2) + NodesCubicX(3) )/3;
    NodesCubicY(10) = ( NodesCubicY(1) + NodesCubicY(2) + NodesCubicY(3))/3;

%     % determining various parameters of the triangular element defined by
%     % Denis Syresin according to the book of Zienkiewicz
%     % the Jacobian and its inverse
%     MeshProps.DS(1,ii) = ( NodesCubicX(2) - NodesCubicX(1) )*( NodesCubicY(3) - NodesCubicY(1) ) ...
%         - ( NodesCubicX(3) - NodesCubicX(1) )*( NodesCubicY(2) - NodesCubicY(1) );  % Jacobian
%     MeshProps.DS(2,ii) = 1/MeshJac(1,ii);                                   % inverse Jacobian
%     %        %round determinant
%     %        power=fix(log10(abs(el_var(2,i))));
%     %        el_var(2,i)=round(el_var(2,i)/10^(power-6))*10^(power-6);
%     
%     % various areas
%     MeshProps.DS(3,ii) = NodesCubicX(2)*NodesCubicY(3) - NodesCubicX(3)*NodesCubicY(2);                              %a(1)
%     MeshProps.DS(4,ii) = NodesCubicX(3)*NodesCubicY(1) - NodesCubicX(1)*NodesCubicY(3);                              %a(2)
%     MeshProps.DS(5,ii) = NodesCubicX(1)*NodesCubicY(2) - NodesCubicX(2)*NodesCubicY(1);                              %a(3)
%     % vectors of the triangle edges
%     MeshProps.DS(6,ii) = NodesCubicY(2) - NodesCubicY(3);                                        %b(1)
%     MeshProps.DS(7,ii) = NodesCubicY(3) - NodesCubicY(1);                                        %b(2)
%     MeshProps.DS(8,ii) = NodesCubicY(1) - NodesCubicY(2);                                        %b(3)
%     MeshProps.DS(9,ii) = NodesCubicX(3) - NodesCubicX(2);                                        %c(1)
%     MeshProps.DS(10,ii) = NodesCubicX(1) - NodesCubicX(3);                                       %c(2)
%     MeshProps.DS(11,ii) = NodesCubicX(2) - NodesCubicX(1);                                       %c(3)
    
    % determining various properties of the mesh triangles, which are defined 
    % in the book of Zienkiewicz, and which are necessary for further
    % computations 
    
    % delta - the area of the triangle built on the nodes 1, 2, 3, half of
    % the vector product
    MeshProps.delta(1,ii) = 1/2*det([ 1, NodesCubicX(1), NodesCubicY(1); ...
                                      1, NodesCubicX(2), NodesCubicY(2); ...
                                      1, NodesCubicX(3), NodesCubicY(3)]);
%    MeshProps.delta(2,ii) = 2*MeshProps.delta(1,ii);
                            
    % coefficients in expansions of interpolating functions L_i over x, y 
    % according to the book of Zienkiewicz
    % L_i = 1/(2*delta) * (a_i + b_i*x + c_i*y)
    % a_1 = x2*y3 - x3*y2, b1 = y2 - y3, c1 = x3 - x2, etc. by cyclic
    % rotation of indices 1, 2, 3
    % x = sum_{i=1:3} L_i*x_i
    % y = sum_{i=1:3} L_i*y_i
    % 1 = sum_{i=1:3} L_i
    
    MeshProps.a(1,ii) = NodesCubicX(2)*NodesCubicY(3) - NodesCubicX(3)*NodesCubicY(2);
    MeshProps.a(2,ii) = NodesCubicX(3)*NodesCubicY(1) - NodesCubicX(1)*NodesCubicY(3);
    MeshProps.a(3,ii) = NodesCubicX(1)*NodesCubicY(2) - NodesCubicX(2)*NodesCubicY(1);
                            
    MeshProps.b(1,ii) = NodesCubicY(2) - NodesCubicY(3);
    MeshProps.b(2,ii) = NodesCubicY(3) - NodesCubicY(1);
    MeshProps.b(3,ii) = NodesCubicY(1) - NodesCubicY(2);
    
    MeshProps.c(1,ii) = NodesCubicX(3) - NodesCubicX(2);
    MeshProps.c(2,ii) = NodesCubicX(1) - NodesCubicX(3);
    MeshProps.c(3,ii) = NodesCubicX(2) - NodesCubicX(1);

    for jj = 4:1:10
        % find whether the added nodes are already present in the table of
        % nodes
        ind = find( MeshNodesCubic(1,:) == NodesCubicX(jj) & MeshNodesCubic(2,:) == NodesCubicY(jj) );
        if isempty(ind)
            % if the node is not in the nodes table yet, add it to the ende
            % of the table and insert its number
            % into the list of the nodes of this triangle
            MeshNodesCubic(1:2,end+1) = [NodesCubicX(jj);NodesCubicY(jj)];
            MeshTriCubic(jj,ii) = length(MeshNodesCubic);
        else
            % if the node is already in the nodes table, insert its number
            % into the list of the nodes of this triangle
            MeshTriCubic(jj,ii) = ind;
        end
    end
       
end

end